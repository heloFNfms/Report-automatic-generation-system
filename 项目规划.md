报告自动生成系统。 使用若依(ruoyi)还有launching的框架

RAG（检索增强生成）+ MCP 工具调用 + 分步骤管道式生成

# 系统逻辑步骤

  ## 🔹 Step 1. 用户输入研究主题

  - **用户操作**：

    1. 输入项目名称

    2. 输入公司名称

    3. 输入研究内容

  - **系统动作**：

    1. 将输入保存到缓存数据库（保证可回溯）。

    2. 向 Orchestrator 发出请求，进入 Step 2。

---

## 🔹 Step 2. 研究大纲生成--大纲专家

  - **输入**：Step 1 的项目名称和研究内容

  - **操作流程**：

    1. 传输给deepseek,然后 DeepSeek 生成结构化大纲（要求三级标题格式）。

    2. 输出 JSON 格式：

      ```Python
{
  "研究大纲": 
    {"一级标题": "背景与意义", "二级标题": ["研究现状", "问题分析"]},
    {"一级标题": "方法", "二级标题": ["模型设计", "实验验证"]}
}
```


  - **输出**：研究大纲

  - **缓存**：存储，允许用户回退修改。

---

## 🔹 Step 3. 研究内容生成--写作助理

  - **输入**：研究大纲

  - **操作流程**：

    1. 对每个二级标题生成搜索 query（逐点检索）。

    2. MCP 搜索 → rerank → 压缩结果 → 提示词（并附加参考网址）。

    3. 将提示词传给deepseek,然后DeepSeek 输出 **分章节研究内容**（逐章写）。

    4. 输出 JSON 格式：

      ```Python
{
  "研究内容": {
    "背景与意义": {
      "研究现状": "...内容...",
      "问题分析": "...内容..."
    },
    "方法": {
      "模型设计": "...内容...",
      "实验验证": "...内容..."
    }
  },
  "参考网址": ["https://...", "https://..."]
}
```


  - **输出**：分章节研究内容 + 参考网址。

  - **缓存**：存储，支持用户逐章修改或重跑。

---

## 🔹 Step 4. 主要报告生成--学术润色师

  - **输入**：大纲 + 内容

  - **操作流程**：

    1. 系统组装成一个 **结构化报告框架**：

      ```Python
标题
正文（分章）
参考文献（来自step3的 URL）
```


    2. 将框架输入 DeepSeek，提示“请润色并生成正式学术报告”。

    3. DeepSeek 输出完整报告。

  - **输出**：最终完整报告。

  - **缓存**：存档，可供用户下载或再次编辑。

---

## 🔹 Step 5. 摘要 & 关键词生成--文摘机器人

  - **输入**：step4的报告

  - 输出：deepseek总结后输出摘要 & 关键词,并输出完整的文章

  ---

## 🔹  Step 6. 在线编辑

  - 生成结束后的技术报告支持在线编辑，提供完备的在线文档功能方便操作

  - 支持导出 PDF / Word。

## 🔹 Step 7. 云端上传

  - 每次生成的文档自动上传到OSS云端数据库内，并且自动归档

# 系统框架

## 1. 前端（RuoYi-Vue）

  - 提供一个 **5 步进度条界面**：

    - Step 1 输入研究主题

    - Step 2 大纲 

    - Step 3 研究内容 + 参考网址

    - Step 4 初始报告生成

    - Step 5 完整报告生成（带关键词和摘要）

  - 每一步结果用 **卡片展开**，网址显示为可点击链接。

  - 支持导出 PDF / Word。

---

## 2. 后端（RuoYi-SpringBoot）

  - 新建一个 **报告生成模块（report-gen）**：

    - `ReportController`：接收前端请求（/step1, /step2 ... /final）

    - `ReportService`：负责调用 LangChain 流程

    - `ReportHistory`：存储用户生成的每一步结果（MySQL）

  - 数据库表结构（例）：

    - `report_task`：记录用户输入、状态

    - `report_step`：存储每一步结果（JSON 格式）

---

## 3. LangChain（编排器）

  - 用 **LangChain** 来编排整个工作流：

    - 工具（Tools）：

      - `arxiv_search(query)`

    - 代理：DeepSeek

    - Memory：存储前一步的结果（摘要/大纲/内容/初始报告/最终报告）。

  - 流程（对应 5 步）：

    1. **Step1**：保存主题

    2. **Step2**：模型输出研究大纲

    3. **Step3**：调用搜索工具 → Rerank → 压缩 → DeepSeek 研究内容+网址

    4. **Step4**：按研究内容模型输出润色好的初版文章

    5. **Step5**：对出版文章模型总结关键词和摘要，输出添加摘要和关键词的完整文章

---

## 4. DeepSeek-MCP 服务器

  - 部署一个 **MCP Server**，注册工具：

    - `arxiv_search`

  - LangChain 调用 MCP → MCP 去请求 API → 返回结果。

---

## 5. 缓存与回退机制

  - 每一步结果存 MySQL → 前端支持“重跑本步骤”。

  - 用户可以回到 前一步重新生成，而不用重跑整个流程。

  - **缓存与性能优化：**

    你用了 MySQL 存结果 👍，再补一个 **向量数据库（Milvus/PGVector）**，存每次的搜索结果 embedding，下次遇到类似 query 可以直接复用。

---

# 现有工具

```Python
# DeepSeek AI配置
deepseek.api.key=sk-fb80d84c81ab42b782b69ed7997a094b
deepseek.api.base-url=https://api.deepseek.com
deepseek.api.model=deepseek-chat

#java版本17
#数据库使用：MYSQL
```


---

## 🏗️ 三层逻辑拆解

  ### 1. **前端（RuoYi-Vue + RuoYi-SpringBoot）**

  - 就是给用户一个「五步走」的流程页面：

    - Step1 输入研究主题

    - Step2 输出大纲

    - Step3 输出研究内容

    - Step4 输出润色后的报告

    - Step5 输出最终带关键词和摘要的报告

  - 后端 Controller 接收前端请求，然后调用 Orchestrator。

  👉 **作用**：负责和用户打交道，数据输入输出。

---

### 2. **Orchestrator 层（report-orchestrator + LangChain）**

  - 它是「大脑管家」，主要负责：

    - 按照 Step1-5 **编排执行顺序**

    - 调用 MCP 工具（外部搜索）

    - 调用 DeepSeek（AI 生成）

    - 做缓存、rerank、chunk、summarization 等逻辑

  👉 **作用**：整个报告生成的「调度中心」。

---

### 3. **工具层（MCP Server = report-mcp）**

  - 它就是一堆「小工具工厂」：

    - MCP Server 注册工具，比如 `arxiv_search`

    - 外部调用 MCP Server，就能拿到对应 API 的结果

  👉 **作用**：统一管理外部 API 调用，把复杂性封装起来。

---

## 🔗 整体调用链（一步步走）

  1. 用户在 **前端** 输入主题 → 点“下一步”

  2. SpringBoot 调用 **Orchestrator (main.py)**

  3. Orchestrator 调用 **mcp_tools.py** → 发 HTTP 请求给 **MCP Server**

  4. MCP Server (`server_search.py`) → 调用arXiv API 或别的搜索接口→ 返回搜索结果

  5. Orchestrator 拿到搜索结果 → 用 `rag.py` 做处理 → 再丢给 DeepSeek (`deepseek.py`)

  6. DeepSeek 生成摘要 / 大纲 / 内容 / 报告

  7. 最终结果存 MySQL → 回到前端显示

---

## ✨  所以总结一句：

👉 **MCP Server** 负责「搜集资料」
👉 **Orchestrator** 负责「编排流程」
👉 **DeepSeek** 负责「写报告」
👉 **前端 / RuoYi** 负责「给用户操作」



